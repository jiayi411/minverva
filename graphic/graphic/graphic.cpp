/*
 *  graphic.cpp
 *  graphic
 *
 *  Created by jiayi on 09/02/2017.
 *  Copyright Â© 2017 jiayi. All rights reserved.
 *
 */

//#include <iostream>
#include "graphic.h"
#include "math/vector2.h"
#include "math/vector3.h"
#include "math/vector4.h"

using namespace minerva::graphic;

template<> vector2 vector2::s_vector_zero = vector2( 0.f, 0.f );

template<> vector3 vector3::s_vector_x = vector3( 1.f, 0.f, 0.f );
template<> vector3 vector3::s_vector_y = vector3( 0.f, 1.f, 0.f );
template<> vector3 vector3::s_vector_z = vector3( 0.f, 0.f, 1.f );
template<> vector3 vector3::s_vector_zero = vector3( 0.f, 0.f, 0.f );

template<> vector4 vector4::s_vector_zero = vector4( 0.f, 0.f, 0.f, 0.f );


namespace minerva { namespace graphic {
    
    void mi_check_glerror()
    {
        mg_enum error = glGetError();
        if (error == GL_NO_ERROR) { return; }
        mi_log( "opengl error: %#x\n", error );
        
        if (error == GL_INVALID_VALUE) {
            mi_assert( 0 && "program is not a value generated by OpenGL." );
        } else if (error == GL_INVALID_OPERATION) {
            mi_assert( 0 && "program is not a program object or has not been successfully linked" );
        }
    }    
    
    mg_uint bind_opengl_buffer( mg_uint type, mg_sizeiptr size, mg_void* buffer, mg_uint draw_type )
    {
        mg_uint buffer_id;
        glGenBuffers(1, &buffer_id);
        glBindBuffer(GL_ARRAY_BUFFER, buffer_id);
        glBufferData(GL_ARRAY_BUFFER, size, buffer, GL_STATIC_DRAW);
        return buffer_id;
    }
    
    mg_uint generate_single_vao()
    {
        GLuint vao_id;
        glGenVertexArrays(1, &vao_id);
        glBindVertexArray(vao_id);
        return vao_id;
    }
    
    void enable_bind_attrib_pointer( mg_uint index, mg_uint buffer_id, mg_int size, mg_void* offset_pointer )
    {
        glEnableVertexAttribArray( index );
        glBindBuffer(GL_ARRAY_BUFFER, buffer_id );
        glVertexAttribPointer(index,
                              size,
                              GL_FLOAT,
                              GL_FALSE,
                              0,
                              (void*)offset_pointer
                              );
    }
    
}}
